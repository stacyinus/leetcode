1. 常见题目。 给了一堆Home的三位坐标（x,y,z)，找出其中一个Home最为Club，使得其到其他Home的距离和最短。 和面试官讨论了，但是他还是比较想要找离各坐标均值最近的Home作为Club的这个做法。 面试官后来也问如果不是Mean，而是Median会怎么样？当时没有答出来，后来和朋友讨论，觉得在此题目中，因为寻找的Club是Home中的一个，
所以Median和Mean在这个题目中的作用是相同的。 

补充：第二题是地里有面经的，给你n个点，坐标（x，y，z），找一个点离其他点的距离之和是最小的。这个题地里面经的答案说是算xyz平均值然后取离这个最近的那个点，
我一开始非常嗨皮的给了这个答案，结果面试官说你这个不对，然后要我写了个On2的解法做优化，我当时想了一会儿确实想不出来怎么优化，结果小哥说用全局变量存当前最小距离，如果当前距离和已经比最小距离小就直接看下一个点。。。 这个优化暂且不说，我想问下神通广大的一亩三分地ers， 这个题能有线性时间的解法吗？我问过我一个acm的同学，他说曼哈顿距离确实没有线性的。。。 

class Location{
	int x;
	int y;
	int z;
	public Location(int x, int y, int z) {
		this.x = x;
		this.y = y;
		this.z = z;
	}
}

public Location getClub(List<Location> locations) {
	int sumx = 0, sumy = 0, sumz = 0;
	for (Location l : locations) {
		sumx += l.x;
		sumy += l.y;
		sumz += l.z; 
	}
	sumx = sumx/locations.size();
	sumy = sumy/locations.size();
	sumz = sumz/locations.size();
	Location c = new Location(sumx, sumy, sumz);
	double dis = Double.MAX_VALUE;
	Location club = null;
	for (Location l : locations) {
		int tmp = getDistance(l, c);
		if (tmp < dis) {
			dis = tmp;
			club = l;
		}
	}
	return club;
}

private double getDistance(Location a, location b) {
	return Math.sqrt(Math.pow((a.x - b.x),2) + Math.pow((a.y - b.y),2) + Math.pow((a.z - b.z),2));
}



2. Fibonaci那题目,没记错的话应当是求和吧。 [1, 1, 2, 3, 5, ...]  sum(1) =1, sum(2)=1+1, sum(3)=1+1+2, ....

补充：然后第二题，是求那个斐波那契数列， 刚开始就写了简单的递归，然后他说给个index，是让返回这个数列所有斐波那契数的和。 只好在写个函数，把每个斐波那契数算出来，加入到一个arraylist里面，再去扫一遍arraylist加到一起。然后问怎么优化，就把算斐波那契数的函数里面改用DP做。 
做完，又问这是最优的么？又说DP的数组可以用滚动数组，开常数空间就好了，他说对，然后又问时间上能优化么？
答可以把dp数组设成全局的，每次调用sum（）这个函数算和的时候，直接去fib（）这个函数里面找就完了。他没再问优化的事情了。


public int fib(int i) {
	if (i <= 0) return 0;
	int[] fib = new int[i];
	fib[0] = 0;
	fib[1] = 1;
	int sum = 1;
	int t = 2;
	while (t <= i) {
		fib[t] = fib[t - 1] + fib[t - 2];
		sum += fib[t];
		t ++;
	}
	return sum;
}


3. 给一个threshold求剩余数的中位数那题。
  ［1，2，3，3，4，5，6，7], threshold=3, 求剩余数组[3, 3, 4, 5, 6, 7]的median，2分查找。  

public int getMerdian(int[] nums, int threshold) {
	if (nums == null || nums.length == 0) return ;//ask about the invalid input
	Arrays.sort(nums);
	//bsearch, find the first greater than or equal to
	int start = bSearchReturnIndex(nums, threshold);
	return (start == -1) ? 0 : getMedian(nums, start, nums.length - 1); 
}

private int bSearchReturnIndex(int[] nums, int target) {
	int i = 0, j = nums.length - 1;
	while (i + 1 < j) {
		int m = i + (j - i) / 2;
		if (nums[m] <= target) {
			j = m;
		}
		else{
			i = m;
		}
	}
	if (nums[i] >= target) return i;
	if (nums[j] >= target) return j;
	return -1;
}
//
private int getMedian(int[] nums, int s, int e) {
	int m = s + (e - s) / 2;// 0 , 1 ,  m = 0? 
	return nums[m];
}

4. 给了一个Array，然后找index，index左右的和一样的。
    [1, 2, 3, 2, 1]，index就是2。1+2 == 2+1
/*
	[1,2,3,3,0]
	[1,3,6,9,9] [9,8,6,3,0] sum1[2 - 1] = sum2[2 + 1]
	int[] sum1;
	int[] sum2;
*/
public static int getIndex(int[] nums) {
	if (nums == null || nums.length == 0) return -1;
	if (nums.length == 1) return nums[0];
	int sum1 = new int[nums.length];
	sum1[0] = nums[0];
	for (int i = 1; i < nums.length - 1; i++) {
		sum1[i] = sum1[i - 1] + nums[i];
	}
	int sum2 = new int[nums.length];
	sum2[nums.length - 1] = nums[nums.length - 1]; 
	for (int i = nums.length - 2;i >= 0; i --) {
		if (i > 0 && sum2[i + 1] == sum1[i - 1]) return i;
		sum2[i] = nums[i] + sum2[i + 1];
	}
	return -1;
}


5.给了一个diction，给了一个word，找出在diction里面所有word的anagram
   diction：［"ab", "abc", "cba", "ba", "abcd"］. From 1point 3acres bbs
   word: "bca"
   result: ["abc", "cba"]

补充： 第一轮：亚洲人，第一题写个AnagramsServer类，实现init(String[] dict)和getAnagrams(String s)两个方法。基本就是让你在init里面把字典里的词都存好，然后getAnagrams的时候可以把和s是anagram的都输出。init调用一次，get调用多次。
class AnagramsServer {
	HashMap<String, List<String>> map;
	String[] dict;

	public AnagramsServer () {
		map = new HashMap<String, List<String>>();
	}

	public init(String[] dict) {
		this.dict = dict;
		for each (String s: dict) {
			String tmp = getFormattedString(s);
			if (map.cotainsKey(tmp)) {
				List tmpList = map.get(tmp);
				tmpList.add(s);
			}
			else {
				List tmpList = new ArrayList<String>();
				tmpList.add(s);
				map.put(s, tmpList);
			}
		}
	}

	public List<String> getAnagrams(String s) {
		String target = getFormattedString(s);
		if (map.containsKey(target)) return map.get(target);
		return new ArrayList<String>();
	}

	private String getFormattedString(String s) {
		char[] tmp = s.toCharArray();
		Arrays.sort(tmp);
		return new String(tmp);
	}	
}


6. 给定一个Matrix，验证右上三角旋转180度是否和左下三角相同。Matrix初定为Square，
其实这道题目应该也有followup，即输入matrix可以不为square。但是时间不够，面试官没有继续问了。
/*
	if there are even number of lines
	
	a,b,c,d,
	i,e,f,g,
	g,f,e,i,
	d,c,b,a

	if there are odd number of lines
	a,b,c
	d,e,d
	c,b,a

	follow up, if input is rectangle? (my function still works.)
	a,  b,c,d
	e,f,  f,e
	d,c,b,  a
*/
public static boolean isSame(char[][] matrix) {
	if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return false; //ask about this 
	int s = 0, e = matrix.length - 1;
	while (s < e) {
		int l = matrix[s].length;
		for (int i = 0; i < l; i ++) {
			if (matrix[s][i] != matrix[e][l - 1 - i]) {
				return false;
			}
		}
		s++;
		e--;
	}
	if (s == e) {
		int i = 0, j = matrix[s].length - 1;
		while(i < j && matrix[s][i] == matrix[s][j]) {
			i++;
			j--;
		}
		return i >= j;
	}
	return true;
}


7. Median of Two sorted Arrays https://leetcode.com/problems/median-of-two-sorted-arrays/




8. Product of Array Except Self https://leetcode.com/problems/product-of-array-except-self/
/*
Given an array of n integers where n > 1, nums, 
return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].

Solve it without division and in O(n).

For example, given [1,2,3,4], return [24,12,8,6].

*/

public class Solution {
    public int[] productExceptSelf(int[] nums) {
        if (nums == null || nums.length < 2) return new int[0];
        int[] p = new int[nums.length];
        int[] q = new int[nums.length];
        int[] r = new int[nums.length];
        p[0] = nums[0];
        q[nums.length - 1] = nums[nums.length - 1];
        for (int i = 1; i < nums.length; i ++) {
            p[i] = p[i - 1] * nums[i];
        }
        r[nums.length - 1] = p[nums.length - 2];
        for (int i = nums.length - 2; i >= 0; i --) {
            q[i] = q[i + 1] * nums[i];
            if (i == 0) r[i] = q[i + 1];
            else    r[i] = p[i - 1] * q[i + 1];
        }
        return r;
    }
}
after follow up :
public class Solution {
    public int[] productExceptSelf(int[] nums) {
        if (nums == null || nums.length < 2) return new int[0];
        int[] p = new int[nums.length];
        p[0] = nums[0];
        for (int i = 1; i < nums.length; i ++) {
            p[i] = p[i - 1] * nums[i];
        }
        int tmp = nums[nums.length - 1];
        p[nums.length - 1] = p[nums.length - 2];
        for (int i = nums.length - 2; i > 0; i --) {
            p[i] = tmp * p[i - 1];
            tmp *= nums[i];
        }
        p[0] = tmp;
        return p;
    }
}

/*
pool  BGRR
guess RGYY

int[] = new int[4];
int l = 0, c = 0;
if l and c both match, l ++;
else {
	int[i]++;
}
*/
9. A solution consists of four balls from a set of four different colors. The user tries to guess the solution.
If they guess the right color for the right spot, record it as being in the correct 'Location'. 
If it's the right color, but the wrong spot, record it as a correct 'Color'. 
For example: if the solution is 'BGRR' and the user guesses 'RGYY' they have 1 'Location' and 1 'Color'. 
A correct solution would be 4 'Location' and 0 'Color'. https://www.careercup.com/question?id=3037



10. Bulls and Cows https://leetcode.com/problems/bulls-and-cows/
/*
"1807"
"7810"

[0,-1,0,0,0,0,0,1,0,0]
*/
public class Solution {
    public String getHint(String secret, String guess) {
        int bull = 0 , cow = 0;
        int[] count = new int[10];
        int i = 0;
        while (i < secret.length()) {
            int c1 = secret.charAt(i) - '0';
            int c2 = guess.charAt(i) - '0';
            if ( c1 == c2 ) bull++;
            else {
            	if (count[c1] < 0) {
            		cow++;
            	}
            	count[c1]++;
            	if (count[c2] > 0) {
            		cow++;
            	}
            	count[c2]--;
            }
            i++;
        }
        return bull + "A" + cow + "B";
    }
}
11. How would you discover a memory leak in a software product that contains thousands of lines?


12. Two sum https://leetcode.com/problems/two-sum/

public class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        if(nums == null || nums.length < 2)
            return null;
        for(int i = 0 ; i< nums.length ; i++){
            if(map.containsKey(nums[i]))
                return new int[]{map.get(nums[i]),i};
            else 
                map.put(target - nums[i], i);
        }
        return null;
    }
}

13. Factorial Trailing Zeroes https://leetcode.com/problems/factorial-trailing-zeroes/

14. Given a 2^31 x 2^31 tic tac toe board, describe how you would store the state of the game to check if there is a winner.
	https://www.careercup.com/question?id=4871704801181696

15. Maximum Subarray https://leetcode.com/problems/maximum-subarray/


16. Find all subsets of a set https://leetcode.com/problems/subsets/

public class Solution {
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> result = new ArrayList<List<Integer>>();
        if (nums == null || nums.length == 0) return result;
        helper(result, new ArrayList<Integer>(), nums, 0);
        return result;
    }

    private void helper(List<List<Integer>> result, List<Integer> list, int[] nums, int s) {
    	result.add(new ArrayList<Integer>(list));
    	for (int i = s ; i < nums.length; i++) {
    		list.add(nums[i]);
    		helper(result, list, nums, i + 1);
    		list.remove(list.size() - 1);
    	}
    }
}

17. Swap nodes in pairs in a linked list https://leetcode.com/problems/swap-nodes-in-pairs/

public class Solution {
    public ListNode swapPairs(ListNode head) {
        if (head == null || head.next == null) return head;
        ListNode next = head.next, nextHead = head.next.next;
        next.next = head;
        head.next = swapPairs(nextHead);
        return next;
    }
}
18. Lowest Common Ancestor of a Binary Search Tree https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/

public class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null || p == null || q == null) return root;
        if (root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p , q);
        if (root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p ,q);
        return root;
    }
}

19. Lowest Common Ancestor of a Binary Tree https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/

public class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null || p == null || q == null) return null;
        if (root == p || root == q) return root;
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p , q);
        if (left != null && right != null) return root;
        if (left != null) return left;
        if (right != null) return right;
        return null;
    }
}

n. reverse integer https://leetcode.com/problems/reverse-integer/
/* 
	1234 -- 4321
	1000 -- 1 remove heading 0
	-1234 -- -4321
	overflow?
*/
public int reverse(int x) {
	long r = 0;
	long n = Math.abs((long) x);
	while (n > 0) {
		int tmp = n % 10;
		r = 10 * r + tmp;
		n /= 10;
	}
	return r > Math.MAX_VALUE? 0 : (x < 0 ? -1 * r : r);
}

n. ?????
reverseBitValue： 1010000 --> 0000101。 这题没见过啊，面经里都没有啊~~~想了想，只能用最navie的方法，说每次右移0到31位，并且将移位完的数跟1这个数做&。 这样看每一位是1还是0，赋给一个变量，然后每次再左移32 - i 位， 再加起来。最后返回。 说完思路，他说他没听懂， 但是他感觉是对的，我擦擦擦擦，都没听懂，还能感觉，这么安慰我。又让我问了问题，然后挂了
    // you need treat n as an unsigned value
public int reverseBits(int n) {        
	/* 
		for each bit do an xor with 1
		1010000 
		1
	*/
	return n ^ ( -1);


}

21. reverse words in a string， leetcode原题。我当时用没有额外空间的方法做了一下，小哥说你这个two pass能不能优化?
/*
Given s = "the     sky  is blue",
return "blue is sky the".
1. consice.
2.
*/
public class Solution {
    public String reverseWords(String s) {
        s = s.trim();
        String[] array = s.split(" ");
        StringBuilder sb = new StringBuilder();
        for (int i = array.length - 1; i >= 0 ; i --) {
            if (array[i].length() > 0){
                sb.append(array[i]);
                if (i > 0) {
                    sb.append(" ");   
                }
            }
        }
        return sb.toString();
    }
}
// better solution
public class Solution {
    public String reverseWords(String s) {
    	char[] a = s.toCharArray();
    	int start = 0, end = a.length - 1;
    	while (start <= end && a[start] == ' ') start++;
    	while (start <= end && a[end] == ' ') end--;
        if (start > end) return "";
    	int i = start, j = start, k = start;
    	while (i <= end) {
    		// make sure i is point to the start of a string
    		while (i <= end && a[i] == ' ') i++;
    		j = i;
    		// j is point to end of the string
    		while (j <= end && a[j] != ' ') j++;
    		// reverse sting from i to j - 1
    		System.out.println("1 reverting " + i + " with " + (j - 1) );
    		reverse(a, i ,j - 1);
    		while (i < j ) {
    			a[k++] = a[i++];
    		}
    	    if (j < end)   a[k++] = ' ';
    	}
    	System.out.println("2 reverting " + start + " with " + (k - 1));
    	reverse(a, start, k - 1 );
    	return new String(a, start, k - start);
    }
    
    private void reverse(char[] a, int i, int j ) {
    	while ( i < j )  {
    		char t = a[i];
    		a[i] = a[j];
    		a[j] = t;
    		i++;
    		j--;
    	}
    }
}

22. 给你一个graph每一个node都是一个facebook的user，然后找出这个user的两度关系以内所有和他last name一样的人的email address

public List<String> getEmail(Node node){
        List<String> result = new ArrayList<String>();
        Queue<Node> queue = new Queue<Node>();
        queue.add(node);
        int count = 2;
        while(!queue.isEmpty()){
                Node curr = queue.poll();
                for(Node neighbor : neighbors){
                        if(neighbor.user != node && neighbor.user.lastname.equals(curr.lastname)){
                                result.add(neighbor.email);
                        }
                        queue.add(neighbor);
                }
                count--;
                if(count == 0){
                        break;
                }
        }
        return result;
}

class Node {
        User user;
        String email;
        List<Node> neighbors;
        public Node (User user, String email){
                this.user = user;
                this.email = email;
        }
}

class User {
        String firstname;
        String lastname;
        public User(String first, String last){
                fisrtname = first;
                lastname = last;
        }
}

?22. Find the Least Common Ancestor given two nodes of a binary tree. 
The nodes each have a reference to their parent node and you do not have the root node of the tree

https://www.careercup.com/question?id=56769
public Node LCA(node A, node B){
        if(height(A) > height(B)){
                return LCA(B, A);
        }
        node t1 = A;
        node t2 = B;
        while(t1 != t2){
                if(t2.parent == null){
                        if(t1.parent == null){
                                return null;
                        }else{
                                t1 = t1.parent;
                        }
                }else{
                        t2 = t2.parent;
                }
        }
        return t1;
}

private int height(node A){
        int count = 0;
        while(A.parent != null){
                count++;
                A = A.parent;
        }
        return count;
}

class Node {
        int val;
        Node parent;
        Node(int x){
                val = x;
        }
}

23. Determine if two rectangular are overlapped
//check两个rectangle是否重叠
// 问面试官如果边重合算不算重叠。
public class Solution {
	public boolean overLap(Node topLeftA, Node topLeftB, Node bottomRightA, Node bottomRightB) {
		if (bottomRightA.x < topLeftB.x || bottomRightB.x < topLeftA.x 
			bottomRightA.y > topLeftB.y || bottomRightB.y > topLeftA.y)
			return false；
		return true;
	}

	public class Node {
                double x;
                double y;
                public Node(double x, double y){
                        this.x = x;
                        this.y = y;
                }
        }	
}

24. First non-repeat character in a given string
Brent Elphick
http://javarevisited.blogspot.com/n14/03/3-ways-to-find-first-non-repeated-character-String-programming-problem.html
/*
	hashmap<character, integer>
	bolean[256]
	abcddeabb
	abcd
	abc

*/
//two pass, and O(n) space
public char getChar(String s) {
	char[] array = s.toCharArray();
	HashMap<Character, Integer> map = new HashMap<Character, Integer>();
	for (char c : array) {
		if (!map.containsKey(c)) {
			map.put(c, 1);
		}
		else {
			map.put(c , map.get(c) + 1);
		}
	}
	for (char c : array) {
		if (map.get(c) == 1) return c;
	}
	return '';
}
//one pass.
public char getChar(String s) {
	char[] array = s.toCharArray();
	HashSet<Character> set = new HashSet<Character>();
	List<Character> list = ArrayList<Character>();
	for (char c : array) {
		if (!set.contains(c)) {
			set.add(c);
			list.add(c);
		} 
		else{
			list.remove(c);// O(n)
		}
	}
	return list.size() == 0? '' :list.get(0);
}


25. Implement a function for blackjack that returns the score of your hand
public int score(Hand hand){
        int score = 0;
        for(Card currentCard : hand){
                switch(currentCard.value){
                        case value.Two:
                                score += 2;
                                break;
                        case value.Three:
                                score += 3;
                                break;
                        case value.Four:
                                score += 4;
                                break;
                        case value.Five:
                                score += 5;
                                break;
                        case value.Six:
                                score += 6;
                                break;
                        case value.Seven:
                                score += 7;
                                break;
                        case value.Eight:
                                score += 8;
                                break;
                        case value.Nine:
                                score += 9;
                                break;
                        case value.Ten:
                        case value.Jack:
                        case value.Queen:
                        case value.King:
                                score += 10;
                                break;
                        case value.Ace:
                                score += 11;
                                break;

                }
        }
        // after evaluating with 11 for each ace, if score has busted,
        //then change each ace value from 11 to 1
        if(score > 21){
                for(Card currentAcecard : hand){
                        if(score < 21){
                                break;
                        }
                        if(currentAcecard.val == value.Ace){
                                score -= 10;
                        }
                }
        }
        return score;
}

??26. 给你一个log file，每一行都有一条记录，包括三个数据：访问时间，user id，访问的page id。然后让你找出访问次数最多的10组3个连续访问page。就是如果user A访问了page 1 2 3，这样 1 2 3 就算被访问了一次。不用考虑时间间隔所以我昨天访问1，今天2，后天3，也能算作连续访问page。我的做法是先用map统计了所有用户的按时间顺序排列好的访问page，然后三个三个加到另一个map里面去count(我用最土的办法 id1_id2_id3 下划线连接)，最后用minHeap找出前10个
public int[] maxFrequencyPage(List<Log> logFile){
        int len = logFile.size();
        //userId 对应一个list，每个list是个hashmap<pageId_list ： 个数>
        //Map<Integer, List<HasshMap<List<Integer>, Integer>>> user_page = new HashMap<>();

        //Map<Integer, List<List<Integer>>> user_page = new HashMap<>();
        Map<Integer, List<Integer>> user_page = new HashMap<>();
        Map<List<Integer>, Integer> count_map = new HashMap<>();
        //List<PQNode> count_map = new ArrayList<PQNode>();
        //Deque<Integer> deque = new LinkedList<Integer>();
        for(Log info : logFile){
                if(!user_page.containsKey(info.userId)){
                        Deque<Integer> deque = new LinkedList<Integer>();
                        user_page.add(info.userId, deque);
                }

                deque = user_page.get(info.userId);
                if(deque.size() == 3){
                       
                        if(!count_map.containsKey(deque)){
                                count_map.put(new LinkedList<Integer>(deque), 1);
                        }else{
                                count_map.put(new LinkedList<Integer>(deque), count_map.get(deque) + 1);
                        }
                        deque.removeFrist();
                        deque.addLast(info.pageId);
                }else{
                        deque.addLast(info.pageId);
                }
        }


        Collections.sort(count_map, new Comparator<Map.Entry<List<Integer>, Integer>>{
                public int compare(Map.Entry<List<Integer>, Integer> a, Map.Entry<List<Integer>, Integer> b){
                        return (b.getValue()).compareTo(a.getValue);
                }
        });

        int i = 0;
        List<Integer>[] result = new ArrayList<Integer>[10];
        for(Map.Entry<List<Integer>, Integer> entry : count_map){
                        result[i++] = entry.getKey();
                        if(i == 10){
                                break;
                        }
                }
        }
        return result;
}

class Log{
        date time;
        int userId;
        int pageId;
        public Log (date time, int userId, int pageId){
                this.time = time;
                this.userId = userId;
                this.pageId = pageId;
        }
}

27. PathSum
public boolean hasSum(TreeNode root, int sum) {
	if (root == null) {
		return false;
	}
	if (root.left == null && root.right == null) {
		return root.val == sum;
	}
	if (root.left == null) return hasSum(root.right, sum - root.val);
	if (root.right == null) return hasSum(root.left, sum - root.val);
	return hasSum(root.right, sum - root.val) || hasSum(root.left, sum - root.val);

}

28. PathSumII:https://leetcode.com/problems/path-sum-ii/
follow up 1.假设不用以leaf node为path的终点，返回所有path
follow up 2.假设path不只是从root开始，从任意一个节点开始都可以 （follow-up of 3）。这里写得稍久了一点，感觉代码也不是很精简，她说对了，就不改了。
public class Solution {
    public List<List<Integer>> pathSum(TreeNode root, int sum) {
        List<List<Integer>> result = new ArrayList<List<Integer>>();
        if (root == null) return result;
        helper(result, new ArrayList<Integer>(), root, sum);
        return result;
    }
    private void helper(List<List<Integer>> result, List<Integer> list, TreeNode root, int sum) {
        list.add(root.val);
        if (root.left == null && root.right == null && sum == root.val) {
            result.add(new ArrayList<Integer>(list));
            return;
        }       
        if (root.left != null) {
            helper(result, list, root.left, sum - root.val);
            list.remove(list.size() - 1);
        }
        if (root.right != null) {
            helper(result, list, root.right, sum - root.val);
            list.remove(list.size() - 1);
        }
        
    }
}

29. 第二个是给一个n*n的matrix，点代表通＃号代表不通，从左上角走到右下角，能不能找到一条可行的路径。这里和lc里面path find不太一样，
上下左右只要通的话都是可以走的，并且不是计算多少条路径，而是能不能至少有一条路径。其实还是蛮简单的用bfs即可，
只是这里面试官不让用递归，说是数据量大容易栈溢出，
于是要我用栈来实现，我中间写错一个小地方还是搞出来了，然后就问我要怎么给这个例子写单元测试，我以前根本没搞过这个，
就说写一个随机生成通或者不通的map的生成器来测试，最后才知道他的意思是写用例的时候要按结果分类。。。
/*
	ooooxoox
	xxxoooox
	oooooooo
	xxoxoxoo

	oox
	ooo
	xoo
	[0,0] -- >[0,1] ---> [0,2]
			  [0,1] ---> [1,1] -- > [1,2] 		 
*/
//iterative

public boolean findPath(char[][] m, int n) {
	if (m[0][0] == '#' || m[n - 1][n - 1] == '#') return false;
	Stack<Node> stack = new Stack<Node>();
	boolean[][] visited = new boolean[n][n];
	stack.push(new Node(0,0));
	visited[0][0] = true;
	while (!stack.isEmpty()) {
		Node cur = stack.peek();
		int i = cur.i;
		int j = cur.j;
		if (i == n - 1 && j == n - 1 ) return true;
		if (j + 1 < n && m[i][j + 1] != '#' && !visited[i][j + 1]) {
			stack.push(new Node(i, j + 1));
			visited[i][j + 1] = true;
		}
		else if (i + 1 < n && m[i + 1][j] != '#' && !visited[i + 1][j]){
			stack.push(new Node(i + 1, j ));
			visited[i + 1][j] = true;
		}
		else if (i - 1 >= 0 && m[i - 1][j] != '#' && !visited[i - 1][j]){
			stack.push(new Node(i - 1, j ));
			visited[i - 1][j] = true;
		}
		else if (j - 1 >= 0 && m[i][j - 1] != '#' && !visited[i][j - 1]){
			stack.push(new Node(i, j - 1 ));
			visited[i][j - 1] = true;
		}
		else {
			stack.pop();
		}
	}
	return false;
}

// recursive is trival
public boolean findPath(char[][] m) {
	boolean[][] visited = new boolean[n][n];
	return find(m, 0, 0, visited);
}
public boolean find(char[][] m, int i, int j , boolean[][] visited) {
	if (i < 0 || i >= n || j < 0 || j >= n || m[i][j] == '#' || visited[i][j]) {
		return false;
	}
	visited[i][j] = true;
	boolean found = find(m, i - 1, j , visited) || find(m, i + 1, j , visited) || 
					find(m, i, j - 1, visited)|| find(m, i, j + 1, visited);
	visited[i][j] = false;				
	return found;
} 


Triangle
https://leetcode.com/problems/triangle/

Pascal's Triangle
https://leetcode.com/problems/pascals-triangle/

Pascal's Triangle II
https://leetcode.com/problems/pascals-triangle-ii/

Implement Trie (Prefix Tree)
https://leetcode.com/problems/implement-trie-prefix-tree/




Validate Binary Search Tree
https://leetcode.com/problems/validate-binary-search-tree/

Merge Two Sorted Lists
https://leetcode.com/problems/merge-two-sorted-lists/

Merge k Sorted Lists
https://leetcode.com/problems/merge-k-sorted-lists/

LRU Cache
https://leetcode.com/problems/lru-cache/

Find Median from Data Stream
https://leetcode.com/problems/find-median-from-data-stream/



BST traverse, 要从左到右竖着输出， vertical print

public List<List<Integer>> traverse(TreeNode root) {
	List<List<Integer>> result = new ArrayList<List<Integer>>();
	if (root == null) return result;

}
private void helper(TreeNode root, List<List<Integer>> result, List<Integer> list) {
	if (root.left == null) {
		list.add(root.val);
		if (root.right != null) {
			helper(root.right, result, list);
		}
		else {
			result.add(list);
		}
	}
	else {
		helper(root.left, result);

	}
	

}

判断一个node 是否是另一个 node 的 child 很简单一个 DFS 搞定
?????????????????????????????

public boolean isChild(TreeNode parent, TreeNode child) {
	
}
word ladder





没有design的题目， 地里的面经好像出现不多， 都是其他LC中的， 能记住的有：
BST traverse, 要从左到右竖着输出， vertical print


第一轮: java细节。flood fill类似，然后一个求解jigsaw啥的。
第二轮：blackjack求分数。tic-tac-toe求胜利 or not， 给的棋盘很大，要用hashmap存，这轮没写完，因为面试官会在写到一半跟我说这样写是不是好些，然后我就全擦了重新写。。
第三轮：atoi，data stream track median
第四轮： hiring manager。zigzag iterator，然后聊项目啥的



 


二面是个美国大叔，上来第一个问题是java static关键字的意义并且拿例子问了下，


这里写得稍久了一点，感觉代码也不是很精简，她说对了，就不改了。 5. 她只准备了以上四题，临时又从题库里找了一题 Reverse Integer, 像这样：int reverse(1234), 返回4321. 写完，她说你这个代码可能会出什么问题？我说int超出范围吧，然后加了个判断，当时有点紧张，不知道写得对不对。








第二题是写扫雷的OnClick方法，不用考虑UI相关的东西，输入是一个已经把雷埋好数字标好的board。
他说主要想看的是你点了一个数字为0的格子时候如何把周围一圈都reveal然后如何继续把是0的格子给处理下去。 


第二轮：美国人，第一题是要求用递归的方式来求一个string的长度，不允许用任何求length相关的libary method。我用substring的方式做出来了。写完后follow up是说我substring复杂度太高，因为要把所有char都copy一遍，所以要我想一个O(n)的。想死都没想出来最后他说你可以用exception的try-catch呀－ －我当时就听醉了。


第二题是给你一个graph每一个node都是一个facebook的user，然后找出这个user的两度关系以内所有和他last name一样的人的email address。＝ ＝这一题很简单但是我当时状态不是很好，BFS写出了两个很傻逼的bug，还都被他抓出来了，所以最后要挂估计就是挂这里了。 第三轮：美国人，第一题是给一个string找第一个unique character，我扫两次做的。follow up，给你的是一个iterator，只能顺着这个iterator走一遍，不允许存下来从头扫。我用linkedHashSet做的＝ ＝，估计他不懂这是什么鬼，现场去查了下发现确实可以，然后follow up就变成了让我讲讲怎么实现一个linkedHashSet。第二题就是leetcode的那个reverse word in string，我嘴贱说可以用split 然后倒着加，他就把input 换成了char[] 然后让我in-place做，然后说如果两个单词中有3个空格，也要reverse到另一边去。无论如何最后是顺利做出来了＝ ＝ 第四轮：亚洲人，比较实际的数据处理题，给你一个log file，每一行都有一条记录，包括三个数据：访问时间，user id，访问的page id。然后让你找出访问次数最多的10组3个连续访问page。就是如果user A访问了page 1 2 3，这样 1 2 3 就算被访问了一次。不用考虑时间间隔所以我昨天访问1，今天2，后天3，也能算作连续访问page。我的做法是先用map统计了所有用户的按时间顺序排列好的访问page，然后三个三个加到另一个map里面去count，最后用minHeap找出前10个。follow up是如何优化空间，我那个时候大脑已经跪了，想了二十分钟想不出来就投降要hint了，然后经过提示就用大小为3的queue来存那连续三个page id，count完之后就扔掉第一个然后读第三个就好，不占用空间。 总体感觉就是题都很简单，但是连续面4个小时真的很吃力，状态一差就容易出低级bug。。。 

链接: https://instant.1point3acres.com/thread/144269
来源: 一亩三分地

一题是斐波那契数列求和，一题是给一个数组，问你从左上走到右下一共多少种路径 https://leetcode.com... 然后直接给了osite 

链接: https://instant.1point3acres.com/thread/141528
来源: 一亩三分地


有OOD，简单的饭店reservation



（1）strlen 用recursion写， 一开始写了个用substr的，O(n^2), 然后写了个O(n)的. more info on 1point3acres.com
（2）2D array 里找pair 那个题目
（3）1到100的序列中有4个missing number，把这4个数找出来
 move i to num[i]
 find 
（4）reverse 字符串的单词顺序


1. find first un-repeatted character in a stream.(注意是stream)
2. given an array, find the pair(A + B) sum which is closest to 0.
3. given a binary code, check whether it is a palindrome binary code.
4. given an integer, reverse its all digits. (eg. 1234 ->4321, we need consider the overflow)
5. given an prefix expression, convert it to a postfix expression(eg. +12 -> 12+)
6. algorithm design, how to design a load balancer for a web system(we need design a good partition or hash methods).


第一轮：中国哥哥. 鐗涗汉浜戦泦,涓€浜╀笁鍒嗗湴
1. Spark是什么？executor是什么？. visit 1point3acres.com for more.
2. SQL table: user_id string. 鐗涗汉浜戦泦,涓€浜╀笁鍒嗗湴
              page_id string
              time string
   Find 1) Recent 90 days. 1point 3acres 璁哄潧
        2) the page that is viewed most by a user
        3) and not viewed by any other 2 users
3. LC原题 Triangle.
4. Given a list of Locations (x, y, z), find the nearest Location to all.
5. Projects: Describe a time when you had a conflict with your teammates?.鐣欏璁哄潧-涓€浜�-涓夊垎鍦�
             What’s your biggest achievement in life?
             ……
. 1point 3acres 璁哄潧
第二轮：印度哥哥
1. float sqrt(int number, float tolerance)
2. Web site hit counter
   Implement this interface: Interface hit counter {. visit 1point3acres.com for more.
                                void increment();
                                int gethits();
                             }. From 1point 3acres bbs
   to calculate the web site hits within 1 minute.

第三轮：印度哥哥
这个印度哥哥比较奇葩，不要求写程序，画图或者pseudo code让他理解你思路就行了
1. find median(int[] array)
2. col1 col2
    x     5
    x     9
    y     7
    …     …
   what kind of data structure can it be?
   filter out everything except x, 8.
3. 25 photos in total. One transaction can rate <= 5 photos.
   How to find the 1st, 2nd, 3rd best photo with least transactions?
   (Hint: 找第二的时候可以用找第一的结果)
4. 忘了...但记得不难lol

第四轮：白manager Bryant
感觉他没准备算法问题，想到哪儿问到哪儿。。。＝＝
1. MapReduce是啥，spark跟普通mapreduce啥区别，什么时候用哪个更好？. Waral 鍗氬鏈夋洿澶氭枃绔�,
2. 列举几个spark的函数哪个只存内存，哪个会写到文件系统上面？.1point3acres缃�
3. 给你个钟的时间，返回时针&分针之间小于180度的那个角的角度: 7点50分 －> (10 - (7 + 5/6)) * 30 = 65度。
                                                  3点50分 －> ((3 + 5/6) + 12 - 10) * 30 = 175度。
4. 聊projects...

第五轮：阿拉伯manager，Bryant说是他的boss＝＝
1. 你对你的岗位有什么问题吗？对zillow有什么问题吗？
2. 两两反转single linked list: A -> B -> C -> D -> E -> F -> G
                        变成: B -> A -> D -> C -> F -> E -> G
3. 聊projects...

之后就HR过来问问面试情况blabla 然后催你说我们发offer一般就只给一周时间答（这也太短了＝＝

面完之后楼主的内心是崩溃的。。说好的就四轮呢？呢？呢？？

anyways总归印象很不错，楼主走的时候（5pm＋？）员工基本都下班了所以工作貌似很有规律～走前HR还带逛办公室，确实是巨大的落地窗啊海景美翻了！～～晚上去market street吃了个生蚝犒劳自己哈哈。。对西雅图好感＋＋！ 鏉


2. Given data like
   Column1   Column2
       a              2
       b              10.1point3acres缃�
       x              8
第一列存a-z的char，第二列存int. visit 1point3acres.com for more.
问，最合适的data structure to store this data？
我用的是C++, 所以举了一些例子，比如HashMap，pair<char, int>, or define a struct.

3. introduce a simple machine learning algorithm that you are most familiar with. from: 1point3acres.com/bbs 
.鐣欏璁哄潧-涓€浜�-涓夊垎鍦�
4. Valid parentheses （LC原题）
