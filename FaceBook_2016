
http://www.1point3acres.com/bbs/forum.php?mod=viewthread&tid=203983&extra=page%3D1%26filter%3Dsortid%26sortid%3D311%26sortid%3D311

1. 3Sum

2. Word Break I
/*
s = "apple bee",
dict = ["apple", "bee", "app"].
aaaaaaaaa
[b]
*/
//On^m
public class Solution {
    public boolean wordBreak(String s, Set<String> wordDict) {
        if (wordDict.contains(s)) return true;
        for (int i = 1; i < s.length(); i++) {
            String tmp = s.substring(0,i);
            if (wordDict.contains(tmp)) {
                if (wordBreak(s.substring(i), wordDict)) return true;
            }
        }
        return false;
    }
}
/*
	dp:
	some more improvement...
	min, max
	applebee
	0010100
	j      = i - max
	i - j + 1 <= max
*/
public class Solution {
    public boolean wordBreak(String s, Set<String> wordDict) {
    	boolean[] a = new boolean[s.length + 1];
    	a[0] = true; 
    	int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;
    	for (String t: wordDict) {
    		min = Math.min(s.length(), min);
    		max = Math.max(s.length(), max);
    	}
    	for (int i = min; i < a.length; i++) {
    		for (int j = i - min; j >= 0 && i - j  <= max ; j--) {
    			if (a[j] && wordDict.contains(s.substring(j, i))) {
    				a[i] = true;
    				break;
    			}
    		}
    	}
    	return a[s.length];
    }
}
follow up: what if you want to return just one set of word break
public class Solution {
    public String wordBreak(String s, Set<String> wordDict) {
        boolean[] canbreak = new boolean[s.length() + 1];//canbreak[i] = true meaning s.substring(0, i) is true
        int[] path = new int[s.length() + 1];
        canbreak[0] = true;
        path[0] = -1;
        for (int i = 1; i < canbreak.length; i++) {
            for (int j = 0; j <= i; j++ ) {
                if (canbreak[j] && wordDict.contains(s.substring(j,i))) {
                    canbreak[i] = true;
                    path[i] = j;//j - i
                    break;
                }    
            }
        }
        if (!canbreak[s.length()]) return "";
        List<String> list = new ArrayList<String>();
        int i = s.length(), j = path[i];
        while (j >= 0) {
            list.add(s.substring(j,i));
            i = j;
            j = path[i];
        }
        StringBuilder sb = new StringBuilder();
        for (int k = list.size() - 1; k >= 0; k --) {
            sb.append(list.get(k));
            if (k != 0) sb.append(" ");
        }
        return sb.toString();
    }
}
public class Solution {
    public boolean wordBreak(String s, Set<String> wordDict) {
        boolean[] a = new boolean[s.length + 1];
        a[0] = true; 
        int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;
        for (String t: wordDict) {
            min = Math.min(s.length(), min);
            max = Math.max(s.length(), max);
        }
        for (int i = min; i < a.length; i++) {
            for (int j = i - min; j >= 0 && i - j  <= max ; j--) {
                if (a[j] && wordDict.contains(s.substring(j, i))) {
                    a[i] = true;
                    break;
                }
            }
        }
        return a[s.length];
    }
}
3. Word Break II
/*
DP Memory search
s = "catsanddog",
dict = ["cat", "cats", "and", "sand", "dog"].

cat sand dog
sand dog

A solution is ["cats and dog", "cat sand dog"].
*/
public class Solution {
	Map<String, List<String>> map = new HashMap<String, List<String>>();
	public List<String> wordBreak(String s, Set<String> wordDict) {
		List<String> result = new ArrayList<String>();
		if (s == null || s.length() == 0) return result;
		if (map.containsKey(s)) return map.get(s);
		for (int i = 1; i <= s.length() ; i ++) {
			String tmp = s.substring(0,i);
			if (wordDict.contains(tmp)) {
				List<String> tmpList = wordBreak(s.substring(i), wordDict);
				if (tmpList.size() > 0) {
					for (String t : tmpList) {
						result.add(tmp + " " + t);
					}
				}
				else if (i == s.length()){
					result.add(tmp);
				}
			}
		}
		map.put(s, result);
		return result;
	}
    
}

4. Decode Ways
/*
dp[i] = number of decode ways for substring from 0  ~ i
3 scenarios : if charAt(i) == 0, dp[i] = dp[i - 2]
			  if charAt(i - 1, i) <= 26 && > 10, dp[i] = dp[i - 1] + dp[i - 2] 
			  if charAt(i - 1, i) > 26, dp [i] = dp[i - 1]
*/
public class Solution {
    public int numDecodings(String s) {
    	if (s == null || s.length() == 0 || s.charAt(0) == '0') return 0;
    	int[] dp = new int[s.length() + 1];
    	dp[0] = 1;
    	dp[1] = 1;
    	for (int i = 2; i <= s.length(); i ++) {
    		if (s.charAt(i - 1) == '0') {
    		    if (!isValid(s.substring(i - 2, i))) return 0;
    			dp[i] = dp[i - 2];
    		}
    		else if (isValid(s.substring(i - 2, i))) {
    			dp[i] = dp[i - 1] + dp[i - 2];
    		}
    		else {
    			dp[i] = dp[i - 1];
    		}
    	}
    	return dp[s.length()];
    }
    private boolean isValid(String s) {
    	if (s.charAt(0) == '0') return false;
    	return Integer.parseInt(s) <= 26;
    }
}

5. Minimum Size Subarray Sum
public class Solution {
    /*
        [1,2,3,4,5] and s = 11
         i
                 j
    */
    public int minSubArrayLen(int s, int[] nums) {
        int min = Integer.MAX_VALUE, i = 0, j = 0, sum = 0 ;
        while (j < nums.length) {
            sum += nums[j];
            while (i <= j && sum >= s) {
                min = Math.min(min, j - i + 1);
                sum -= nums[i++];
            }
            j++;
        }
        return min == Integer.MAX_VALUE ? 0 : min;
    }
}

6. Add and Search Word - Data structure design 
Follow up: support “*” which matchs 0 or more characters

public class WordDictionary {
    TrieNode trie = new TrieNode();
    class TrieNode {
        TrieNode[] nodes;
        boolean isword;
        public TrieNode() {
            nodes = new TrieNode[26];
            isword = false;
        }
        public void addWord(String s) {
            if (s.length() == 0) {
                isword = true;
                return;
            }
            char c = s.charAt(0);
            if (nodes[c - 'a'] == null) nodes[c - 'a'] = new TrieNode();
            nodes[c - 'a'].addWord(s.substring(1));
        }
        
        public boolean search(String s) {
            if (s.length() == 0) {
                return isword;
            }
            char c = s.charAt(0);
            if (c == '.') {
                for (TrieNode n : nodes) {
                    if(n != null && n.search(s.substring(1))) return true;
                }
                return false;
            }
            else if (c == '*') {
            	//if * represents 0 characters
            	String tmp = s.substring(1);
            	if(search(tmp)) return true;
            	//if * represents >=1 chars
            	for (TrieNode n : nodes) {
                    if(n != null && n.search(s)) return true;
                }
                return false;
            }
            else {
                if (nodes[c - 'a'] == null) return false;
                return nodes[c - 'a'].search(s.substring(1));
            }
        }
    }
    public void addWord(String word) {
        trie.addWord(word);
    }

    public boolean search(String word) {
        return trie.search(word);
    }
}

7. Intersection of Two Arrays I/II

Intersection of Two Arrays I: array nums1 and nums1 with size of m and n

1.if arrays are sorted, we can binary search , for each element in the smaller array, binary search that 
element in the large array.

2.if nums1 is significantly smaller than nums2, nums2 is in a disk and can not load to memory at once. we should use the 
hashset method, load everything in nums1 into the set, and divide nums2 into small chuncks to process.

public class Solution {
    //  use hashset:no sort  O(m + n)
        public int[] intersection(int[] nums1, int[] nums2) {
        Set<Integer> set = new HashSet<Integer>();
        for (int i = 0; i < nums1.length; i ++) { // O(m)
            set.add(nums1[i]);
        }
        Set<Integer> intersection = new HashSet<Integer>();
        for (int i = 0; i < nums2.length; i++) { // O(n)
            if (set.contains(nums2[i])) intersection.add(nums2[i]);
        }
        int[] result = new int[intersection.size()];
        int index = 0;
        for (Integer i : intersection) {
            result[index++] = i;
        }
        return result;
    }
}	

Intersection of Two Arrays II: almost same with above problem...


8. 蓄水池问题：给一个数组和一个数N， 随机返回该数组中任意一个不大于N的数。
http://www.geeksforgeeks.org/reservoir-sampling/

public int randome(int[] nums, int n) {
	
}

// A function to randomly select k items from stream[0..n-1].
void selectKItems(int stream[], int n, int k)
{
    int i;  // index for elements in stream[]
 
    // reservoir[] is the output array. Initialize it with
    // first k elements from stream[]
    int reservoir[k];
    for (i = 0; i < k; i++)
        reservoir[i] = stream[i];
 
    // Use a different seed value so that we don't get
    // same result each time we run this program
    srand(time(NULL));
 
    // Iterate from the (k+1)th element to nth element
    for (; i < n; i++)
    {
        // Pick a random index from 0 to i.
        int j = rand() % (i+1);
 
        // If the randomly  picked index is smaller than k, then replace
        // the element present at the index with new element from stream
        if (j < k)
          reservoir[j] = stream[i];
    }
 
    printf("Following are k randomly selected items \n");
    printArray(reservoir, k);
}

变种1：给一个l*w的矩阵，要随机取k个点。
http://www.1point3acres.com/bbs/forum.php?mod=viewthread&tid=204601&extra=page%3D1%26filter%3Dsortid%26sortid%3D311%26searchoption%5B3046%5D%5Bvalue%5D%3D2%26searchoption%5B3046%5D%5Btype%5D%3Dradio%26sortid%3D311


9. longest substring with at most K distinct charcaters
/*
	aabcabc
	i  j
*/
public class Solution {
    public int longestSubstring(String s, int k) {
        int i = 0, j = 0;
        Map<Character, Integer> count = new HashMap<Character, Integer>();
        int max = 0;
        while (j < s.length) {
        	char c = s.charAt(j++);
        	count.put(c, count.containsKey(c) ? count.get(c) + 1: 1);
        	if (count.size() > k) {
        		while (map.size() > k) {
        			char c = s.charAt(i++);
        			if (map.get(c) == 1) map.remove(c);
        			else map.put(c, map.get(c) - 1);
        		}
        	}
        	max = Math.max(max, j - i);
        }
        return max;
    }
}

10. Longest Substring with At Least K Repeating Characters(LC 395)
/*
s = "ababbc", k = 2

*/
public class Solution {
    public int longestSubstring(String s, int k) {

    }
}


10. Find longest arithmetic subsequence in an unsorted array.
/*
{1, 7, 10, 15, 27, 29}
[1, 2]
[0, 6,]

*/
public List<Integer> findLongestArithmeticProgression(int[] nums) {
	
}

11. Merge Intervals :LC 88
Given [1,3],[2,6],[8,10],[15,18],
return [1,6],[8,10],[15,18].
[8,10]
/**
 * Definition for an interval.
 * public class Interval {
 *     int start;
 *     int end;
 *     Interval() { start = 0; end = 0; }
 *     Interval(int s, int e) { start = s; end = e; }
 * }
 */
public class Solution {
    public List<Interval> merge(List<Interval> intervals) {
    	//first sort intervals if they are not sorted already
    	List<Interval> result = new ArrayList<Interval>();
    	if (intervals == null || intervals.size() == 0) return result;
    	Collections.sort(intervals, new MyComparator());
    	Interval cur = intervals.get(0);
    	for (int i = 1; i < intervals.size(); i++) {
    		Interval tmp = intervals.get(i);
    		if (cur.end < tmp.start) {
    			result.add(cur);
    			cur = tmp;
    		}
    		else {
    			cur.end = Math.max(cur.end, tmp.end);
    		}
    	}
    	result.add(cur);
    	return result;
    }
    class MyComparator implements Comparator<Interval> {
       // @Override
    	public int compare(Interval i1, Interval i2) {
    		return (i1.start == i2.start) ? i1.end - i2.end : i1.start - i2.start;
    	}
    }
}


12. Implement Iterator: given iterator of 2 sorted arraylist, implement an iterator to 
iterator the 2 array in order(sorted)

class SortedIterator{
	Iterator it1;
	Iterator it2:
	List<Integer> list;
    public SortedIterator(Iterator a, Iterator b){
    	it1 = a;
    	it2 = b;
    }
    public boolean hasNext() {
    	return list.size() > 0 || it1.hasNext() || it2.hasNext();
    }
    public int next(){
    	if (list.size() == 0) {
    		if (!hasNext()) throw new Exception();
    		if (it1.hasNext()) list.add(it1.next());
    		if (it2.hasNext()) list.add(it2.next());
    	}
    	int num = 0;
    	if (list.size() == 1) {
    		num = list.get(0);
    		list.remove(0);
    	}
    	else {
    		int i = list.get(0) <= list.get(1) ? 0 : 1;
    		num = list.get(i);
    		list.remove(i);
    	}
    	return num;
    }
}
follow up, if it is a list of sorted arraylists

13. 给一个 二叉树 ， 求最深节点的最小公共父节点。
http://www.1point3acres.com/bbs/forum.php?mod=viewthread&tid=199739&extra=page%3D1%26filter%3Dsortid%26sortid%3D311%26searchoption%5B3046%5D%5Bvalue%5D%3D2%26searchoption%5B3046%5D%5Btype%5D%3Dradio%26sortid%3D311

http://www.1point3acres.com/bbs/forum.php?mod=viewthread&tid=199548&extra=page%3D1%26filter%3Dsortid%26sortid%3D311%26searchoption%5B3046%5D%5Bvalue%5D%3D2%26searchoption%5B3046%5D%5Btype%5D%3Dradio%26sortid%3D311
     1
  2   3
     5  6    return 3.

       1  
    2   3
4      5 6   retrun 1. 

       1  
    2   3
4      	   retrun 4. 
/*
	bfs : find the last level
*/
public TreeNode findLCA(TreeNode root) {
	Queue<TreeNode> q = new LinkedList<TreeNode>();
	q.add(root);
	List<TreeNode> curLevel = null;
	while (!q.isEmpty()) {
		int size = q.size();
		curLevel = new ArrayList<TreeNode>();
		for (int i = 0; i < size; i++) {
			TreeNode cur = q.pop();
			curLevel.add(cur);
			if (cur.left != null) q.add(cur.left);
			if (cur.right != null ) q.add(cur.right);
		}
	}
	if (curLevel.size() == 0) return null;
	if (curLevel.size() == 1) return curLevel.get(0);
	rerturn findLCA(root, curLevel.get(0), curLevel.get(curLevel.size() - 1));
}

private TreeNode findLCA (TreeNode root, TreeNode n1, TreeNode n2) {
	if (root == null) return null;
	if (root == n1 || root == n2) return root;
	TreeNode left = findLCA(root.left, n1, n2); 
	TreeNode right = findLCA(root.right, n1, n2); 
	if (left != null && right != null) return root;
	if (left != null) return left;
	return right;
}


//DFS????????
private static class Solution {
        private class ReturnVal {
            public int depth;   //The depth of the deepest leaves on the current subtree
            public TreeNode lca;//The lca of the deepest leaves on the current subtree

            public ReturnVal(int d, TreeNode n) {
                depth = d;
                lca = n;
         	}
        }

        public TreeNode LowestCommonAncestorOfDeepestLeaves(TreeNode root) {
            ReturnVal res = find(root, 0);
            return res.lca;
        }
        private ReturnVal find(TreeNode root, int depth) {. From 1point 3acres bbs
            if(root == null) {
                return new ReturnVal(-1, null);
            } else {
                ReturnVal lRes = find(root.left, depth+1);
                ReturnVal rRes = find(root.right, depth+1);

                if(lRes.depth == rRes.depth) {
                    return new ReturnVal(lRes.depth==-1?depth:lRes.depth, root);
                } else {
                    return new ReturnVal(Math.max(rRes.depth, lRes.depth), rRes.depth>lRes.depth?rRes.lca:lRes.lca);
                }
            }
        }
}

14. Binary Search Tree Iterator(LC 173)
/**
 * Definition for binary tree
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */

public class BSTIterator {
    Stack<TreeNode> stack;
    
    public BSTIterator(TreeNode root) {
        stack = new Stack<TreeNode>();
        while (root != null) {
            stack.push(root);
            root = root.left;
        }
    }

    /** @return whether we have a next smallest number */
    public boolean hasNext() {
        return !stack.isEmpty();
    }

    /** @return the next smallest number */
    public int next() {
        if (!hasNext()) return 0;
        TreeNode cur = stack.pop();
        int val = cur.val;
        TreeNode node = cur.right;
        while (node != null) {
            stack.push(node);
            node = node.left;
        }
        return cur.val;
    }
}

15. BST to Doubly LinkedList


public Node turnToList(TreeNode root) {
		
}


16. Reversely print the singly linked list without modifying the list. Spce complexity should be O(logn)

/*
	1 -> 2 -> 3-> 4-> 5 ->null
		 i
	j
*/

public void print(Node head) {
	if (head == null) return;
	if (head.next == null) {
		System.out.println(head.val);
		return;
	}
	Node fast = head, slow = head.next;
	while (fast != null && fast.next != null) {
		fast = fast.next.next;
		slow = slow.next;
	}
	print (slow);
	print (head);
}

17. The Skyline Problem  218	

public class Solution {
    class Node implements Comparable{
        int x;
        int y;
        boolean start;
        public Node(int x, int y, boolean start) {
            this.x = x;
            this.y = y;
            this.start = start;
        }
        @Override
        public int compareTo(Node n) {
            if (y == n.y) {
                if (start == n.start)   return 0;
                if (start) return 1;
                return -1;
            }
            return n.y - y;
        }
    }
    public List<int[]> getSkyline(int[][] buildings) {
        List<int[]> result = new ArrayList<int[]>();
        List<Node> starts = new ArrayList<Node>();
        List<Node> ends = new ArrayList<Node>();
        for (int i = 0; i < buildings.length ; i ++) {
            starts.add(new Node (buildings[0], buildings[2], true));
            ends.add(new Node (buildings[1], buildings[2], false));
        }
        starts.addAll(ends);
        PriorityQueue<Node> q = PriorityQueue<Node>();
        q.offer(0);
        int pre = 0, cur = 0;
        for (int i = 0 ; i < list.size(); i++) {
            Node toAdd = starts.get(i);
            cur = q.peek();
            if (!toAdd.start) {
                Node toPop = q.pop();
                result.add(new int[2] {toPop.});
            }
            q.offer(n.y);
            cur = q.peek().y;
            if (pre != cur) {
                
            }
            
        }
        result.add();
    }
}

18. Add binary LC67

11100 - a
  101 - s2
    
public class Solution {
    public String addBinary(String a, String b) {
    	int i = a.length() - 1, j = b.length() - 1;
    	StringBuilder sb = new StringBuilder();
    	boolean carry = false;
    	while (i >= 0 || j >= 0) {
    		int ca = i >= 0 ? a.charAt(i--) - '0' : 0;
    		int cb = j >= 0 ? b.charAt(j--) - '0' : 0;
    		int c = carry? (ca + cb + 1) : (ca + cb);
    		carry = c > 1;
    		c = c >= 2? c - 2 : c;
    		sb.append((char) (c + '0'));
    	}
    	if (carry) sb.append('1');
    	return sb.reverse().toString();
    }
}

public class Solution {
    public String addBinary(String a, String b) {
    	int i = a.length() - 1, j = b.length() - 1;
    	StringBuilder sb = new StringBuilder();
    	int carry = 0;
    	while (i >= 0 || j >= 0) {
    		int ca = i >= 0 ? a.charAt(i--) - '0' : 0;
    		int cb = j >= 0 ? b.charAt(j--) - '0' : 0;
    		int c = ca ^ cb ^ carry;
    		carry = (ca & cb) | (ca & carry) | (cb & carry);
    		sb.append((char) (c + '0'));
    	}
    	if (carry > 0) sb.append('1');
    	return sb.reverse().toString();
    }
}	

19. Regular Expression LC10

public class Solution {
    public boolean isMatch(String s, String p) {
        //System.out.println("Matching " + s + " with " + p);
        if (p.length() == 0) return s.length() == 0;
        if (s.length() == 0) return p.length() > 1 && p.charAt(1) == '*' && isMatch(s, p.substring(2));
        if (p.charAt(0) == '*') return false;
        if (p.length() > 1 && p.charAt(1) == '*') {
            if (isMatch(s, p.substring(2))) return true;
            for (int i = 0 ; i < s.length(); i ++) {
                if (s.charAt(i) == p.charAt(0) || p.charAt(0) == '.') {
                    if (isMatch(s.substring(i + 1), p.substring(2))) return true;
                }
                else return false;
            }
        }
        else if (s.charAt(0) == p.charAt(0) || p.charAt(0) == '.') {
            return isMatch(s.substring(1), p.substring(1));
        }
        return false;
    }
}

1, If p.charAt(j) == s.charAt(i) :  dp[i][j] = dp[i-1][j-1];
2, If p.charAt(j) == '.' : dp[i][j] = dp[i-1][j-1];
3, If p.charAt(j) == '*': 
   here are two sub conditions:
               1   if p.charAt(j-1) != s.charAt(i) : dp[i][j] = dp[i][j-2]  //in this case, a* only counts as empty
               2   if p.charAt(i-1) == s.charAt(i) or p.charAt(i-1) == '.':
                              dp[i][j] = dp[i-1][j]    //in this case, a* counts as multiple a 
                           or dp[i][j] = dp[i][j-1]   // in this case, a* counts as single a
                           or dp[i][j] = dp[i][j-2]   // in this case, a* counts as empty
Here is the solution

public boolean isMatch(String s, String p) {

    if (s == null || p == null) {
        return false;
    }
    boolean[][] dp = new boolean[s.length()+1][p.length()+1];
    dp[0][0] = true;
    for (int i = 0; i < p.length(); i++) {
        if (p.charAt(i) == '*' && dp[0][i-1]) {
            dp[0][i+1] = true;
        }
    }
    for (int i = 0 ; i < s.length(); i++) {
        for (int j = 0; j < p.length(); j++) {
            if (p.charAt(j) == '.') {
                dp[i+1][j+1] = dp[i][j];
            }
            if (p.charAt(j) == s.charAt(i)) {
                dp[i+1][j+1] = dp[i][j];
            }
            if (p.charAt(j) == '*') {
                if (p.charAt(j-1) != s.charAt(i) && p.charAt(j-1) != '.') {
                    dp[i+1][j+1] = dp[i+1][j-1];
                } else {
                    dp[i+1][j+1] = (dp[i+1][j] || dp[i][j+1] || dp[i+1][j-1]);
                }
            }
        }
    }
    return dp[s.length()][p.length()];
}
20. Kth Largest Element in an Array LC215
3,2,1,5,6,4

public class Solution {
    public int findKthLargest(int[] nums, int k) {
        PriorityQueue<Integer> pq = new PriorityQueue<Integer>();
        for (int i = 0; i < k; i ++) {
            pq.offer(nums[i]);
        }
        for (int i = k; i < nums.length; i ++) {
            if (nums[i] >= pq.peek()) {
                pq.poll();
                pq.offer(nums[i]);
            }
        }
        return pq.peek();
    }
		// partition
	public int findKthLargest(int[] nums, int k) {
	    return quickSelection(nums, 0, nums.length - 1, nums.length - k + 1);
	}
	/*
     2,1,3,0,6,5         2nd
     0,1,2,3,6,5 -> 2 - 3rd 
                 -> 3

     1,2 - 1
	*/
	public int findKthSmallest(int[] input, int s, int e, int k)  {// 1,2,3,4,5,6
	    int i = partition(input, s, e);
	    if (i + 1 == k) return input[i];//
	    if (i + 1 < k) return quickSelection(input, i + 1, e, k);//([2,1], 1,1,1)
	    return quickSelection(input, s, i - 1, k);
	}
	    
	    public int partition(int[] input, int s, int e) {//0,1,2,6,5
	    	//System.out.println("Current array: " + Arrays.toString(input));
	    	int p = input[s];
	    	while (s < e) {
	    		while (s < e && input[e] >= p) {
	    			e--;
	    		}
	    		input[s] = input[e];
	    		while (s < e && input[s] <= p) {
	    			s++;
	    		}
	    		input[e] = input[s];
	    	}
	    	input[s] = p;
	    	return s;
	    }
}


21. Letter Combinations of a Phone Number LC17
/* "3"
2 - a,b,c
3 - ad,ae,af

*/
public class Solution {

    public List<String> letterCombinations(String digits) {
        if (digits == null || digits.length() == 0)  return new ArrayList<String>();
        HashMap<Character, List<String>> map = new HashMap<Character, List<String>>();
        map.put('2', Arrays.asList("a","b","c") );
        map.put('3', Arrays.asList("d","e","f") );
        map.put('4', Arrays.asList("g","h","i") );
        map.put('5', Arrays.asList("j","k","l") );
        map.put('6', Arrays.asList("m","n","o") );
        map.put('7', Arrays.asList("p","q","r","s") );
        map.put('8', Arrays.asList("t","u","v") );
        map.put('9', Arrays.asList("w","x","y","z") );

        Queue<String> q = new LinkedList<String> (map.get(digits.charAt(0)));
        int k = 1;
        while (k < digits.length()) {
        	int size = q.size();
        	List<String> list = map.get(digits.charAt(k));
        	for (int i = 0; i < size; i++) {
        		String p = q.poll();
        		for (String s : list) {
        			q.offer(p+ s);
        		}
        	}
        	k++;
        }
        List<String> result = new ArrayList<String>();
        while (!q.isEmpty()) result.add(q.poll());
        return result;
    }
22. LC283 Move Zeroes
public class Solution {
    public void moveZeroes(int[] nums) {
        int i = 0;
        while (i < nums.length && nums[i] != 0) {
            i++;
        }
        int j = i;
        while (j < nums.length) {
            while (j < nums.length && nums[j] == 0) {
                j++;
            }
            if (i < nums.length && j < nums.length) swap(nums, i++ , j++);
        }
    }
    private void swap(int[] nums, int i , int j){
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }
    
}

23. LC278 First Bad Version
public class Solution extends VersionControl {
    public int firstBadVersion(int n) {
        int s = 1, e = n;
        while (s < e) {
            int m = s + (e - s)/2;
            if (isBadVersion(m)) e = m;
            else s = m + 1;
        }
        return s;
    }
}


24. Binary Tree to Doubly Linked List (in order),  end is connect to head.
public Node turnToList(TreeNode root) {
    
}
public Node turnToList (TreeNode root) {
    if (root == null) return null;
    Node head = new Node(root.val);
    Node left = turnToList(root.left);
    Node right = turnToList(root.right);
    if (left != null) {
        head.next = left;
        left.pre = head;
        if (right != null) {
            while (left.next != null) {
                left = left.next;
            }   
            left.next = right;  
            right.pre = left;
        }
    }
    else if (right != null){
        head.next = right;
        right.pre = head;
    }
    return head;
}

25. Doubly Linked List to balanced  tree.



26. largest size of island instead of number of islands (LC 200)

public class Solution {
    public int largestSizeIslands(char[][] grid) {
        if (grid == null || grid.length == 0 || grid[0].length == 0) return 0;
        int max = 0;
        boolean[][] visited = new boolean[grid.length][grid[0].length];
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[i].length; j++) {
                if (!visited[i][j] &&grid[i][j] == '1') {
                    int count = dfs(grid, visited, i, j, 0);
                    max = Math.max(count, max);
                }
            }
        }
        return max;
    }
    public int dfs(char[][] grid, boolean[][] visited, int i, int j, int size) {
        if (i < 0 || i > grid.length - 1 || j < 0 || j > grid[i].length - 1 || visited[i][j] || grid[i][j] == '0') return size;
        visited[i][j] = true;
        size++; 
        size = dfs(grid, visited, i - 1, j, size);
        size = dfs(grid, visited, i + 1, j, size);
        size = dfs(grid, visited, i, j - 1, size);
        size = dfs(grid, visited, i, j + 1, size);
        return size;
    }
}

27. 第一题 flatten tree to linked list
      a
   b   c
d   e  f      to     d->b->e->a->f->

public TreeNode flatten (TreeNode root) {
		
}



28. 第二题 strStr()，然后求复杂度


29. 
1 longest path in the tree, start at any node and stop at any node; follow up 树很深；
3 conditions: 
1) cross root
2) in left subtree
3) in right subtree

class Node {
	int depth;
	int max;
	public Node (int d, int m) {
		depth = d;
		max = m;
	}
}
public int longestPath (TreeNode root) {
	if (root == null) return 0;
	Node n = traverse(root);
	return n.max;
}
public Node traverse(TreeNode root) {
	if (root == null) {
		reutrn new Node (0, 0);
	}
	Node left = traverse(root.left);
	Node right = traverse(root.right);
	int depth = Math.max(left.depth, right.depth) + 1;
	int crossRoot = left.depth + right.depth + 1;
	int max = Math.max(Math.max(left.max, right.max), crossRoot);
	Node cur = new Node(depth, max);
	return cur;
}

LC124 Max Path Sum
public class Solution {
	class Node {
		int max;
		int rootToLeaveMax;
		public Node(int i , int j) {
			max = i;
			rootToLeaveMax = j;
		}
	}
    public int maxPathSum(TreeNode root) {
    	Node n = traverse(root);
    	return n.max;
    }

    private Node traverse(TreeNode root) {
    	if (root == null) return new Node (Integer.MIN_VALUE, Integer.MIN_VALUE);
    	if (root.left == null && root.right == null) return new Node(root.val, root.val); 
    	Node left = traverse(root.left);//-2, -2
    	Node right = traverse(root.right);// 3, 3
    	int rootToLeave = Math.max(Math.max(left.rootToLeaveMax, right.rootToLeaveMax) + root.val, root.val);
    	int crossRoot = root.val;
    	
    	if (left.rootToLeaveMax > 0) {
    		crossRoot += left.rootToLeaveMax;
    	}
    	if (right.rootToLeaveMax > 0) {
    		crossRoot += right.rootToLeaveMax;
    	}
    	
    	int max = Math.max(Math.max(left.max, right.max), crossRoot);
    	return new Node(max, rootToLeave);
    }
}

Minimum Window Substring

S = "ADOBECODEBANC"
	 i
	      j
T = "ABC"
A:1
B:1
C:1
public String minWindow(String s, String t) {
	Map<Character, Integer> counts = new HashMap<Character, Integer>();
	Map<Character, Integer> countt = new HashMap<Character, Integer>();
	for (int i = 0; i < t.length(); i ++ ) {
		char c = t.charAt(i);
		countt.put(c, countt.containsKey(c) ? countt.get(c) + 1 : 1 );
	}
	String result = "";
	int i = 0, j = 0;
	while (j <= s.length()) {
		if (contains(counts,countt)) {
			String tmp = s.substring(i, j);
			result = (result.length() > tmp.length() || result.length() == 0 ) ? tmp : result;
			char c = s.charAt(i++);
			if (counts.containsKey(c)) {
				counts.put(c, counts.get(c) - 1);
			}
		}
		else if (j < s.length()){
			char c = s.charAt(j++);
			if (countt.containsKey(c)) {
				counts.put(c, counts.containsKey(c) ? counts.get(c) + 1 : 1);
			}
		}
		else {
			j++;
		}
	}
	return result;
}
private boolean contains(Map<Character, Integer> map1, Map<Character, Integer> map2) {
	for (Map.Entry<Character, Integer> entry : map2.entrySet()) {
		if (!map1.containsKey(entry.getKey()) || map1.get(entry.getKey()) < entry.getValue()) return false;
	}	
	return true;
}
30. interger to string, LC 上那题稍微变一下， 可能为负数；
public String intToString(int n) {
	
}
314. Binary Tree Vertical Order Traversal

class Node {
    int i;
    TreeNode n;
    public Node(int i, int n) {
        this.i = i;
        this.n = n;
    }
}
public List<List<Integer>> traverse(TreeNode root) {
    int l = 0, r = 0;
    TreeNode tmp = root;
    while (root != null) {
        l++;
        root = root.left;
    }
    tmp = root;
    while (root != null) {
        r++;
        root = root.right;
    }
    List<List<Integer>> result = new ArrayList<List<Integer>>();
    for (int i = 0 ; i < l + r + 1; i ++) {
        result.add(new ArrayList<Integer>);
    }
    Queue<Node> q = new LinkedList<Node>();
    q.push(new Node(l + 1, root));
    while (!q.isEmpty()) {
        int size = q.size();
        for (int i = 0; i < size; i ++) {
            Node cur = q.pop();
            result.get(cur.i).add(cur.n.val);
            if (cur.n.left != null) {
                q.offer(new Node(cur.i - 1, cur.n.left));
            }
            if (cur.n.right != null) {
                q.offer(new Node(cur.i + 1, cur.n.right));
            }
        }
    }
    return result;
}


LC257 Binary Tree Paths
public class Solution {
    public List<String> binaryTreePaths(TreeNode root) {
        List<String> result = new ArrayList<String> ();
        if (root == null) return result;
        traverse(result, "", root);
        return result;
    }
    private void traverse(List<String> result, String cur, TreeNode root) {
        cur = cur.length() == 0 ? Integer.toString(root.val) : (cur + "->" + root.val);
        if (root.left == null && root.right == null) {
            result.add(cur);
            return;
        }
        if (root.left != null) {
            traverse(result, cur, root.left);
        }
        if (root.right != null) {
            traverse(result, cur, root.right);
        }
    }
}




刚面的。. 鐗涗汉浜戦泦,涓€浜╀笁鍒嗗湴
一烙印面的，上来一道简单的题，intersection of two arrays。 看到这么简单的还挺激动，但故事肯定不是这么简单啦。
先把简单的two pointer解法写完，然后问可不可优化。尼玛，都O(m + n)了，还要咋。
于是说如果一个特长，那就binary search吧。好写完了。问如何优化？ 尼玛，都mlog(n)了，还咋样啊。. more info on 1point3acres.com
于是说如果找到了，一个元素，那就用这次的index作为下次binary search的开始。可以节约掉之前的东西，不用search了。然后问，如果找不到呢，如何优化。尼玛. 鐗涗汉浜戦泦,涓€浜╀笁鍒嗗湴
折腾了一会儿，说如果找不到，也返回上次search 结束的index，然后下次接着search。终于时间到了。
感觉要黑也是有操作空间的。
现在FB是不是喜欢问follow up， 而不是2个问题了？ 鏉


30. 
public String add(String s1, String s2, int base) {
    StringBuilder sb = new StringBuilder();
    boolean carry = false;
    int i = s1.length() - 1, j = s2.length() - 1;
    while (i >= 0 || j >= 0 ) {
        int a = i >= 0? s1.charAt(i--) - '0' : 0;
        int b = j >= 0? s2.charAt(j--) - '0' : 0;
        int s = carry? (a + b + 1) : (a + b);
        carry = false;
        if (a + b >= base) {
            carry = true;
            s -= base;
        }
        sb.append(s);
    }
    return sb.reverse.toString();
}
public String substract(String s1, String s2, int base) {
    StringBuilder sb = new StringBuilder();
    boolean carry = false;
    int i = s1.length() - 1, j = s2.length() - 1;
    while (i >= 0 || j >= 0 ) {
        int a = i >= 0? s1.charAt(i--) - '0' : 0;
        int b = j >= 0? s2.charAt(j--) - '0' : 0;
        int s = carry? (a - 1 - b) : (a - b);
        carry = false;
        if (s < 0) {
            carry = true;
            s += base;
        }
        sb.append(s);
    }
    return sb.reverse.toString();    
}

next ????FB昂赛特 求问Reference 
4. Design autocomplete in a search engine

5. behavior question. 最后的coding是

6.design  pocketmon ,  google search suggestion.
Map store previous values ( O(N) )
把第一题extend到2D。给一个matrix, all elements are positive，问有没有个sub rectangle加起来和等于target。return true/false。
Lz听到题目有点懵，认真调整心态，解决之。先写了个cumulative sum。把所有从0,0 到i,j的和算在新的matrix的i,j上。方便之后算head到tail的sub rectangle的和。这一步O(n^2)



Task那道题，很多面经都提到过。就是比如给你一串task，再给一个cooldown，执行每个task需要时间1，两个相同task之间必须至少相距cooldown的时间，问执行所有task总共需要多少时间。比如执行如下task：12323，假设cooldown是3。总共需要的时间应该是 1 2 3 _ _ 2 3，也就是7个单位的时间。再比如 1242353，假设cool down是4，那总共时间就是 1 2 4 _ _ _ 2 3 5 _ _ _ 3，也就是13个单位的时间
基于1，给出最优的排列，使得字符串最短。


自然string comparator。不知道的搜下。就是string 比较的时候考虑里面数字的大小，比如 abc9 < abc123 abc > ab9  因为char比digit重要。

117. Populating Next Right Pointers in Each Node II
salbring tree，不过没有next指针， 你要用原来的left，right指针

Level BFS


binary tree转换成doubly linked list
And revert it back (reverted to balanced tree): 109. Convert Sorted List to Binary Search Tree

. 1point3acres.com/bbs
75. Sort Colors

Print a binary tree by columns top to bottom.

We're given a sorted array of integers: [-3, -1, 0, 1, 2]. We want to generate a sorted array of their squares: [0, 1, 1, 4, 9]

list of sorted integer arrays，要求找所有的数的median. e.g. [1,3,6,7,9], [2,4, 8], [5], return 5

two sum + three sum + follow up
. 1point3acres.com/bbs
Best Time to Buy and Sell Stock, (I and II)
buy and sell stock，每天可以买一股，也可以都卖了，或者不买不卖。

Find maximum, buy from earlier days, and sell on that day.


33. Search in Rotated Sorted Array

38. Count and Say
. 1point 3acres 璁哄潧
sparse vector dot multiplication
这道题我当时并没有准备到，但是正因为如此，我认为我跟面试官的交流给我加分了不少。面试官首先问我每个vector很大，并不能在内存中存下，该怎么办，我说只需要存下非零的元素和他们的下标就行，然后询问面试官是否可以用预处理后的这两个vector非零元素的index和value作为输入，面试官同意后快速写完O(M*N)的代码，M和N分别是两个vector的长度。面试官说这两个输入如果是根据下标排序好的话应该怎么办，我说可以遍历长度较短的那一个，然后用二分搜索的方法在另一个vector中找index相同的元素，相乘加入到结果中，这样的话复杂度就是O(M*logN)。这时，面试官又问是否可以同时利用两个输入都是排序好这一个特性，我在这个地方有点卡住，但是在白板上写出一个test case，试着用可视化的方法帮助我来进行思考，同时面试官给了一些提醒，最后写出了O(M + N)的双指针方法
然后问如果有一个向量比另一个长很多怎么办，遍历短的，对长的二分查找。
两个vector相乘


211. Add and Search Word
. 鍥磋鎴戜滑@1point 3 acres
239. Sliding Window Maximum

282. Expression Add Operators

158. Read N Characters Given Read4 II - Call multiple times
.1point3acres缃�
49. Group Anagrams - use counting sort

linked list 反序输出 - 1) reverse the list; 2) recursion

问题一：flatten an array?

285. Inorder Successor in BST

283. Move Zeroes
Minimizing “writes”


5. Longest Palindromic Substring
62. Unique Paths I/II

moving all the nonzeros to the front of a list。
. 鐣欏鐢宠璁哄潧-涓€浜╀笁鍒嗗湴
Prettify JSON:  输入[1,2,3, {"id": 1, "name": "wang", "tag":[1,"home",2], "price":234}]

Smallest subarray with sum greater than a given value:

flatten nested array



114. Flatten Binary Tree to Linked List
Linked list needs to be formed as a cycle


301. Remove Invalid Parentheses (hard)
Maintain counter and go from left to right, remove when necessary, then counter must be > 0, then remove “(“ from right hand side

. 1point 3acres 璁哄潧
218. The Skyline Problem (hard)
. Waral 鍗氬鏈夋洿澶氭枃绔�,
278. First Bad Version

Min Queue, 跟Min Stack类似， 实现一个Queue， 然后O（1）复杂度获得这个Queue里最小的元素。

interval [startTime, stoptime)   ----integral  time stamps
给这样的一串区间 I1, I2......In  
找出 一个 time stamp  出现在interval的次数最多。
startTime <= t< stopTime 代表这个数在区间里面出现过。
example：  [1,3),  [2, 7),   [4,  8),   [5, 9)
5和6各出现了三次， 所以答案返回5，6。  (Hard)

shortest continuous substring with all characters in input
76. Minimum Window Substring


合并邮件列表（后来才知道也是个面经题）
Given 1 million email list:
list 1: a@a.com, b@b.com
list 2: b@b.com, c@c.com
list 3: e@e.com
list 4: a@a.com
...
Combine lists with identical emails, and output tuples:
(list 1, list 2, list 4) (a@a.com, b@b.com, c@c.com)
(list 3) (e@e.com)

79. Word Search

输出所有 root - leaf 的路径，递归做完了让迭代。
Iterative? BFS?


17. Letter Combinations of a Phone Number

28. Implement strStr()

398. Random Pick Index

37. Sudoku Solver

一个完全树。node有parent指针。
每个node的值为 0或 1
每个parent的值为两个子node的 “and” 结果
现在把一个leaf翻牌子（0变1或者1变0）. visit 1point3acres.com for more.
把树修正一遍

200. Number of Islands

BST to increasing array
Recursive, iterative
173. Binary Search Tree Iterator

BST iterator
Iterator for a list of BSTs (heap contain each BST’s iterator)

128. Longest Consecutive Sequence

22. Generate Parentheses

238. Product of Array Except Self

191. Number of 1 Bits

给2D平面上的N个点，求离原点最近的K个点
.1point3acres缃�
33. Search in Rotated Sorted Array
. more info on 1point3acres.com
找出两个给出两个string, leetcode, codyabc和一个数字k = 3,问两个string里面存不存在连续的common substring大于等于k.比如这个例子，两个string都有cod,所以返回true。楼主用dp建了一个m*n的table秒了，然后写test case,发现有个小corner case,改了,pass
Longest common substring
.鐣欏璁哄潧-涓€浜�-涓夊垎鍦�

给定一个数列，比如1234，将它match到字母上，1是A，2是B等等，那么1234可以是
ABCD
但是还可以是12是L，所以1234也可以写作
LCD 或者
AWD

给出N个序列，比如2个序列A,B,没个序列包含若干的区间，比如
A: [1,5], [10,14], [16,18]
B: [2,6], [8,10], [11,20]
Merge them all:  [1,6], [8, 20].

balance parentheses in a string
例子：
"(a)()" -> "(a)()"
"((bc)" -> "(bc)"
")))a((" -> "a"
"(a(b)" ->"(ab)" or "a(b)"
Note: balance的意思就是把原来string里unpaired的括号变成paired的形式。如果有多个可能的结果， 比如上述最后一种情况，我们就只需要输出一个对的结果即可，所以这点简化了题目的难度。感受： 遍历string， 用一个stack存储每个open parenthesis的index，也就是'('的index, 每当遇到closed parenthesis就执行一次pop操作。
注意两种unbalanced的情况：
1. 出现多余的')':
    对应情况就是stack为空，但遇到了一个')'。
2. 出现多余的'(':
    对应情况就是遍历结束，stack未空

get binary tree's next node in inorder
class Node {Node left, Node right, Node parent}
Node getNext (Node current) {}

给一个tree，每个node 有很多children，
找到所有最深的nodes 的common  ancestor,
比如只有一个点最深，那返回他自己。
Similar to 236. Lowest Common Ancestor of a Binary Tree


78. Subsets
90. Subsets II

341. Flatten Nested List Iterator

102. Binary Tree Level Order Traversal

给三个funtions: is_low(), is_mid(), is_high(). 让给一个数组排序, low的放在最前面, mid的放在中间, high的放在最后面.
Color sort: think about when there are K colors


39. Combination Sum
.鏈枃鍘熷垱鑷�1point3acres璁哄潧
125. Valid Palindrome
214. Shortest Palindrome

98. Validate Binary Search Tree
.鏈枃鍘熷垱鑷�1point3acres璁哄潧
Longest Arithmetic Progression)

10. Regular Expression Matching

211. Add and Search Word

138. Copy List with Random Pointer

71. Simplify Path

Maximal square:

[3,2,1,7,2]
[3,3,]
198. House Robber
public class Solution {
    public int rob(int[] nums) {
        if( nums == null || nums.length == 0 )
            return 0;
        if( nums.length == 1 )
            return nums[0];
        int[] tmp = new int[nums.length];
        tmp[0] = nums[0];
        tmp[1] = Math.max(nums[0], nums[1]);
        for( int i = 2; i < nums.length; i++ )
            tmp[i] = Math.max(tmp[i-1], tmp[i-2] + nums[i]);
        return tmp[nums.length - 1];
    }
}
House RobberII
public class Solution {
    public int rob(int[] nums) {
        if (nums == null || nums.length == 0) return 0;
        if (nums.length == 1) return nums[0];
        int[] a = new int[nums.length];
        int[] b = new int[nums.length];
        a[0] = nums[0];
        a[1] = Math.max(a[0], nums[1]);
        b[1] =nums[1];
        int max = 0;
        for (int i = 2 ; i < nums.length; i ++) {
            a[i] = Math.max(a[i - 1], a[i - 2] + nums[i]);
            b[i] = Math.max(b[i - 1], b[i - 2] + nums[i]);
        }
        return Math.max(a[nums.length - 2], b[nums.length - 1]);
    }
}
53. Maximum Subarray
-google 1point3acres
152. Maximum Product Subarray

32. Longest Valid Parentheses

277. Find the Celebrity
. 鍥磋鎴戜滑@1point 3 acres
56. Merge Intervals
Variant: 一串start time － end time，格式是Apr 2010 － Mar 2011这种，要求计算出这些时间的总跨度，重叠的跨度不重复计算。举例：["Apr 2010 - Dec 2010", "Aug 2010 - Dec 2010", "Jan 2011 - Mar 2011"]


57. Insert Interval

206. Reverse Linked List

implement circular array
Circular buffer


Check big/small endian

第一题：binary tree，给定一个value，return bin tree里面下一个比value大的值
第二题：binary tree的node加一个ptr next，point到inorder traversal的下一个node，比上一个简单

297. Serialize and Deserialize Binary Tree

Given a list of number, there is only one peak or one drop. Find the maximum drop.
Exps:
1 -> 2 -> 3 -> 9 -> 3 -> 0 = 9;
10 -> 4 -> 3 -> 8 = 7 ;

224. Basic Calculator

43. Multiply Strings

282. Expression Add Operators

顺时针的print binary tree boundary, 就是从根开始，先打右边界，再打叶子，最后打左边界。

310. Minimum Height Trees

不用“／”，“％”运算符实现division，说了可以用binary search

273. Integer to English Words

111. Minimum Depth of Binary Tree
.鐣欏璁哄潧-涓€浜�-涓夊垎鍦�
找两个字符串中长度为N以上的共同子串

117. Populating Next Right Pointers in Each Node I / II

29. Divide Two Integers

一个数组内要是存在至少三个升序的数（array[x] < array[y] < array[z], x < y < z）就返回true

161. One Edit Distance

print max depth path of a binary tree
. 鐣欏鐢宠璁哄潧-涓€浜╀笁鍒嗗湴
151. Reverse Words in a String

261. Graph Valid Tree
any connected graph without simple cycles is a tree.
. visit 1point3acres.com for more.

给一个linkedlist，里面的element都排序好了，但是是一个blackbox，有三个function可以调用。pop()随机pop出最前面或最后面的element，peek()随机偷看最前面或最后面的element，isEmpty()回传linkedlist是不是空了。问设计一个资料结构，list或是array都可以，把linkedlist里面所有的element都拿出来，并保持他们的排序。followup是如果不能用peek()该怎么做。
My thinking: if I got element A, and next element B is smaller than A, then A is from the tail of the list; otherwise, A is from the head of the list.


133. Clone Graph

Erase duplicate in an unsorted array

几何算法问题。如果给你一堆的矩形， 求重合矩形重合最多的坐标位置。我上过一个算法课，大概思路就是做一个二维的meeting room II

给定N个2D坐标（可以设想为餐厅的位置），要求输入任意坐标，可以返回方圆d距离内的所有餐厅

65. Valid Number

253. Meeting Rooms II
求最多interval的时间点，返回任意一个就行。
. from: 1point3acres.com/bbs 



补充内容 (2016-9-30 07:30):
一夜暴富了。。。谢谢大家。我昨天又做了一些修改，删去重复，合并了一些。另外一些难题的还写了写代码。可是帖子不能编辑啊？太菜了。

PS，刚刚面了FB第一轮，iterator for merging K sorted arrays